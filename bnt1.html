<!DOCTYPE html>
<html lang="en" class="no-js">

<head>
	<meta charset="UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>CODEHUB</title>
	<meta name="description" content="Blueprint: A basic template for a responsive multi-level menu" />
	<meta name="keywords" content="blueprint, template, html, css, menu, responsive, mobile-friendly" />
	<meta name="author" content="Codrops" />
	<link rel="shortcut icon" href="favicon.ico">
	<!-- food icons -->
	<link rel="stylesheet" type="text/css" href="css/organicfoodicons.css" />
	<!-- demo styles -->
	<link rel="stylesheet" type="text/css" href="css/demo.css" />
	<!-- menu styles -->
	<link rel="stylesheet" type="text/css" href="css/component.css" />
	<script src="js/modernizr-custom.js"></script>
</head>

<body>
	<!-- Main container -->
	<div class="container">
		<!-- Blueprint header -->
		<header class="bp-header cf">
			<div class="dummy-logo">
				<div class="dummy-icon foodicon foodicon--coconut"></div>
				<h2 class="dummy-heading">codehub</h2>
			</div>
			<div class="bp-header__main">
				<span class="bp-header__present">CODEHUB <span class="bp-tooltip bp-icon bp-icon--about" data-content="The Blueprints are a collection of basic and minimal website concepts, components, plugins and layouts with minimal style for easy adaption and usage, or simply for inspiration."></span></span>
				<h1 class="bp-header__title">Tips And Tricks</h1>
				<nav class="bp-nav">
					<a class="bp-nav__item bp-icon bp-icon--prev" href="http://tympanus.net/Blueprints/PageStackNavigation/" data-info="previous Blueprint"><span>Previous Blueprint</span></a>
					<!--a class="bp-nav__item bp-icon bp-icon--next" href="" data-info="next Blueprint"><span>Next Blueprint</span></a-->
					<a class="bp-nav__item bp-icon bp-icon--drop" href="http://tympanus.net/codrops/?p=25521" data-info="back to the Codrops article"><span>back to the Codrops article</span></a>
					<a class="bp-nav__item bp-icon bp-icon--archive" href="http://tympanus.net/codrops/category/blueprints/" data-info="Blueprints archive"><span>Go to the archive</span></a>
				</nav>
			</div>
		</header>
		<button class="action action--open" aria-label="Open Menu"><span class="icon icon--menu"></span></button>
		<nav id="ml-menu" class="menu">
			<button class="action action--close" aria-label="Close Menu"><span class="icon icon--cross"></span></button>
			<div class="menu__wrap">
				<ul data-menu="main" class="menu__level" tabindex="-1" role="menu" aria-label="All">
					<li class="menu__item" role="menuitem"><a class="menu__link" data-submenu="submenu-1" aria-owns="submenu-1" href="#">Basic Programming</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" data-submenu="submenu-2" aria-owns="submenu-2" href="#">DataStructures</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" data-submenu="submenu-3" aria-owns="submenu-3" href="#">Algorithm</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" data-submenu="submenu-4" aria-owns="submenu-4" href="#">Math</a></li>
				</ul>
				<!-- Submenu 1 -->
				<ul data-menu="submenu-1" id="submenu-1" class="menu__level" tabindex="-1" role="menu" aria-label="Vegetables">
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="inout.html">Input/Output</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="compana.html">Complexity Analysis</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="impl.html"Implimentation</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#">Operators</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#">Bit Manipulation</a></li>
					<!--<li class="menu__item" role="menuitem"><a class="menu__link" data-submenu="submenu-1-1" aria-owns="submenu-1-1" href="#">Sale %</a></li>-->
				</ul>
				<!-- Submenu 1-1 -->
				<!--<ul data-menu="submenu-1-1" id="submenu-1-1" class="menu__level" tabindex="-1" role="menu" aria-label="Sale %">
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#">Fair Trade Roots</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#">Dried Veggies</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#">Our Brand</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#">Homemade</a></li>
				</ul>-->
				<!-- Submenu 2 -->
				<ul data-menu="submenu-2" id="submenu-2" class="menu__level" tabindex="-1" role="menu" aria-label="Fruits">
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="array.html">Arrays</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="stacks.html">Stacks</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#">Queue</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#">Hashtable</a></li>
				</ul>
				<!-- Submenu 3 -->
				<ul data-menu="submenu-3" id="submenu-3" class="menu__level" tabindex="-1" role="menu" aria-label="Grains">
					<li class="menu__item" role="menuitem"><a class="menu__link" data-submenu="submenu-3-1" aria-owns="submenu-3-1" href="#">Searching</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" data-submenu="submenu-3-2" aria-owns="submenu-3-2" href="#">Sorting</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#">Greedy algorithm</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#">Graph</a></lid>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#">String</a></li>
					
				</ul>
				<!-- Submenu 3-1 -->
				<ul data-menu="submenu-3-1" id="submenu-3-1" class="menu__level" tabindex="-1" role="menu" aria-label="Promo Packs">
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="linearsearch.html"> Linear Search</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="binaryse.html">Binary Search</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="ternaryse.html">Ternary Search</a></li>
				</ul>
				<!-- Submenu 3-2 -->
				<ul data-menu="submenu-3-2" id="submenu-3-2" class="menu__level" tabindex="-1" role="menu" aria-label="Promo Packs">
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="bubsort.html">Bubble Sort</a></li>
					
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="merge.html">Merge Sort</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="quick.html">Quick Sort</a></li>
					
				</ul>
				<!-- Submenu 4 -->
				<ul data-menu="submenu-4" id="submenu-4" class="menu__level" tabindex="-1" role="menu" aria-label="Mylk &amp; Drinks">
					<li class="menu__item" role="menuitem"><a class="menu__link" data-submenu="submenu-4-1" aria-owns="submenu-4-1" href="#">Number-Theory</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" data-submenu="submenu-4-2" aria-owns="submenu-4-2" href="#">Combinatorics</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" data-submenu="submenu-4-3" aria-owns="submenu-4-3" href="#">Geometry</a></li>
				</ul>
				<!-- Submenu 4-1 -->
				<ul data-menu="submenu-4-1" id="submenu-4-1" class="menu__level" tabindex="-1" role="menu" aria-label="Selection">
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="bnt1.html">Basic Number-Theory 1</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="bnt2.html">Basic Number-Theory 2</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="prim.html">Primarily Test</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="totient.html">Totient Function</a></li>

				</ul>
				<!-- Submenu 4-2 -->
				<ul data-menu="submenu-4-2" id="submenu-4-2" class="menu__level" tabindex="-1" role="menu" aria-label="Selection">
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="basc.html">Basics Of Combinatorics</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#">Inclusion-Exclusion</a></li>
				</ul>
				<!-- Submenu 4-3 -->	
				<ul data-menu="submenu-4-3" id="submenu-4-3" class="menu__level" tabindex="-1" role="menu" aria-label="Selection">
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#"><a href="sweep.html">Line Sweep Techniques</a></li>
					<li class="menu__item" role="menuitem"><a class="menu__link" href="#">line-intersection-using-bentley-ottmann-algorithm</a></li>
				</ul>
			</div>
		</nav>
		<div class="content">
			<p class="info">
				<h1>Basic Number Theory-1</h1>
				<p><strong>Introduction</strong></p>
<p>This article discusses topics that are frequently used to solve programming problems based on math. It includes the following topics:
</p><ol>
<li>Modular arithmetic</li>
<li>Modular exponentiation</li>
<li>Greatest Common Divisor (GCD)</li>
<li>Extended Euclidean algorithm</li>
<li>Modular multiplicative inverse</li>
</ol><p></p>
<p><strong>1. Modular arithmetic</strong></p>
<p>When one number is divided by another, the modulo operation finds the remainder. It is denoted by the  \%  symbol.</p>
<p><strong><em>Example</em></strong></p>
<p>Assume that you have two numbers 5 and 2.  5 \%2   is 1 because when 5 is divided by 2, the remainder is 1.</p>
<p><strong><em>Properties</em></strong></p>
<ol>
<li> (a + b) \% c = (a \% c + b \% c) \% c </li>
<li> (a * b) \% c = ((a \% c) * (b \% c)) \% c </li>
<li> (a - b) \% c = ((a \% c) - (b \% c) + c) \% c </li>
<li> (a / b) \% c = ((a \% c) * (b^{-1} \% c)) \% c </li>
</ol>
<p><strong>Note</strong>: In the last property,  b^{-1}  is the multiplicative modulo inverse of b and c.</p>
<p><strong><em>Examples</em></strong></p>
<p>If   a = 5, b = 3 , and  c = 2 , then:</p>
<ul>
<li> (5 + 3) \% 2 = 8 \% 2 = 0 <br />
Similarly,  (5 \% 2 + 3 \% 2) \% 2 = (1 + 1) \% 2 = 0   </li>
<li> (5 * 3) \% 2 = 15 \% 2 = 1 <br />
Similarly,  ((5 \% 2) * (3 \% 2) ) \% 2 = (1 * 1) \% 2 =  1 </li>
</ul>
<p>If  a = 12, b = 15 , and  c = 4 , then the answer in some languages is  (12 - 15) \% 4 = (12 \% 4 - 15 \% 4) \% 4 = (0 - 3) \% 4 = -3 . However, the answer of the  \%  operator cannot be negative.</p>
<p>Therefore, to make the answer positive, add c to the formula and compute it as follows:<br />
 (12 - 15) \% 4 = (12 \% 4 - 15 \% 4 + 4) \% 4 = (0 - 3 + 4) \% 4 = 1 </p>
<p><strong><em>When are these properties used?</em></strong></p>
<p>Assume that a =  10^{18} , b =  10^{18} , and c =  10^9 + 7 . You have to find  (a * b) \% c .</p>
<p>When you multiply a with b, the answer is  10^{36} , which does not conform with the standard integer data types. Therefore, to avoid this we used the properties.</p>
<p> (a * b) \% c = ((a \% c) * (b \% c)) \% c = (49 * 49) \% (10^{9} + 7) = 2401 </p>
<p><strong>2. Modular exponentiation</strong><br />
Exponentiation is a mathematical operation that is expressed as  x^n  and computed as  x^n = x\cdot x\cdot...\cdot x   ( n  times). </p>
<p><strong><em>Basic method</em></strong> </p>
<p>While calculating  x^n , the most basic solution is broken down into  x \cdot x^{n-1} . The new problem is  x^{n-1} , which is similar to the original problem. Therefore, like in original problem, it is further broken down to  x \cdot x \cdot x^{n-2} . </p>
<p>This is a recursive way of determining the answer to  x^n . However, sometimes an equation cannot be broken down any further as in the case of  n = 0 . A C++ code for this solution, considering  n \ge 0  is as follows: </p>
<p></p><pre class="prettyprint"><code>int recursivePower(int x,int n)
{
    if(n==0)
        return 1;
    return x*recursivePower(x,n-1);
}
</code></pre>
The recursive method aligns with the explanation, however, the solution can also be written in an iterative format, which is quite ad hoc. A variable 'result', to which  x  is multiplied for  n  number of times, is maintained.<p></p>
<p>The iterative code is as follows:</p>
<p></p><pre class="prettyprint"><code>int iterativePower(int x,int n)
{
    int result=1;
    while(n&gt;0)
    {
        result=result*x;
        n--;
    }
    return result;
}
</code></pre>
<strong><em>Time complexity</em></strong><p></p>
<p>With respect to time complexity, it is a fairly efficient <em>O(n)</em> solution. However, when it comes to finding  x^n , where  n  can be as large as  10^{18} , this solution will not be suitable.  </p>
<p><strong><em>Optimized method</em></strong> </p>
<p>While calculating  x^n , the basis of Binary Exponentiation relies on whether  n  is odd or even. </p>
<p>If  n  is even, then  x^n  can be broken down to  (x^2)^{n / 2} . Programmatically, finding  x^2  is a one-step process. However, the problem is to find  (x^2)^{n/2} . </p>
<p>Notice how the computation steps were reduced from  n  to  n / 2  in just <strong>one</strong> step? You can continue to divide the power by  2  as long as it is even.</p>
<p>When  n  is odd, try and convert it into an even value.  x^n  can be written as  x \cdot x^{n-1} . This ensures that  n - 1  is even.  </p>
<ul>
<li>If  n  is even, replace  x^n  by  (x^2)^{n / 2} .</li>
<li>If  n  is odd, replace  x^n  by  x \cdot x^{n - 1} .  n - 1  becomes even and you can apply the relevant formula.</li>
</ul>
<p><strong><em>Example</em></strong></p>
<p>You are required to compute  3^{10} . The steps are as follows:</p>
<ol>
<li>
<p>The power of  3  is  10 , which is even. Break it down as
    follows:<br />
 $3^{10} \Rightarrow  (3^2)^5 \Rightarrow  9^5  $  </p>
</li>
<li>
<p>Find  9^5 . The power of  9  is  5 , which is odd. Convert it into an even power and then apply the following formula:<br />
 9^5 \Rightarrow 9 \cdot 9^4 \Rightarrow 9 \cdot (9^2)^2 \Rightarrow 9 \cdot (81^2) </p>
</li>
<li>
<p> 81^2  is a one-step computation process</p>
</li>
</ol>
<p>The result is  9\cdot81\cdot81 = 59049 .</p>
<p>This is an efficient method and the <em>ten-step process</em> of determining  3^{10}  is reduced to a <em>three-step process</em>. At every step,  n  is divided by  2 . Therefore, the time complexity is <em>O(log N)</em>. </p>
<p>The code for the process is as follows:  </p>
<p></p><pre class="prettyprint"><code>int binaryExponentiation(int x,int n)
{
    if(n==0)
        return 1;
    else if(n%2 == 0)        //n is even
        return binaryExponentiation(x*x,n/2);
    else                             //n is odd
        return x*binaryExponentiation(x*x,(n-1)/2);
}
</code></pre>
An iterative version of this method is as follows:  <p></p>
<p></p><pre class="prettyprint"><code>int binaryExponentiation(int x,int n)
{
    int result=1;
    while(n&gt;0)
    {
        if(n % 2 ==1)
            result=result * x;
        x=x*x;
        n=n/2;
    }
    return result;
}
</code></pre>
However, storing answers that are too large for their respective datatypes is an issue with this method. In some languages the answer will exceed the range of the datatype while in other languages it will timeout due to large number multiplications. In such instances, you must use modulus (%). Instead of finding  x^n , you must find  (x^n)  %  m .   <p></p>
<p>For example, run the implementation of the method to find  2^{10^9} . The  O(n)  solution will timeout, while the  O(log N)  solution will run in time but it will produce garbage values.  </p>
<p>To fix this you must use the modulo operation i.e. %  M  in those lines where a temporary answer is computed.</p>
<p></p><pre class="prettyprint"><code>int modularExponentiation(int x,int n,int M)
{
    if(n==0)
        return 1;
    else if(n%2 == 0)        //n is even
        return modularExponentiation((x*x)%M,n/2,M);
    else                             //n is odd
        return (x*modularExponentiation((x*x)%M,(n-1)/2,M))%M;

}
</code></pre>
Similarly, the iterative binary exponentiation method can be modified as follows:  <p></p>
<pre class="prettyprint"><code>int modularExponentiation(int x,int n,int M)
{
    int result=1;
    while(n&gt;0)
    {
        if(power % 2 ==1)
            result=(result * x)%M;
        x=(x*x)%M;
        n=n/2;
    }
    return result;
}
</code></pre>
<p><strong><em>Recursive solution analysis</em></strong> </p>
<ul>
<li>Time complexity: O(log N)</li>
<li>Memory complexity: O(log N) because a function call consumes memory and log N recursive function calls are made</li>
</ul>
<p><strong><em>Iterative solution analysis</em></strong></p>
<ul>
<li>Time complexity: O(log N)</li>
<li>Memory complexity: O(1)</li>
</ul>
<p><strong>3. Greatest Common Divisor (GCD)</strong></p>
<p>The GCD of two or more numbers is the largest positive number that divides all the numbers that are considered. For example, the GCD of 6 and 10 is 2 because it is the largest positive number that can divide both 6 and 10.</p>
<p><strong><em>Naive approach</em></strong></p>
<p>Traverse all the numbers from min(A, B) to 1 and check whether the current number divides both A and B. If yes, it is the GCD of A and B.</p>
<p></p><pre class="prettyprint"><code>int GCD(int A, int B) {
    int m = min(A, B), gcd;
    for(int i = m; i &gt; 0; --i)
        if(A % i == 0 &amp;&amp; B % i == 0) {
            gcd = i;
            return gcd;
        }
}
</code></pre>
<strong><em>Time Complexity</em></strong><p></p>
<p>The time complexity of this function is <em>O(min(A, B))</em>.</p>
<p><strong>Euclid's algorithm</strong></p>
<p>The idea behind this algorithm is  GCD(A, B) = GCD(B, A \% B) . It will recurse until  A \% B = 0 .</p>
<p></p><pre class="prettyprint"><code>int GCD(int A, int B) {
    if(B==0)
        return A;
    else
        return GCD(B, A % B);
}
</code></pre>
<strong><em>Example</em></strong><p></p>
<p>If a = 16 and B = 10, then the GCD is computed as follows:  </p>
<ul>
<li>GCD(16, 10) = GCD(10, 16 % 10) = GCD(10, 6)</li>
<li>GCD(10, 6) = GCD(6, 10 % 6) = GCD(6, 4)</li>
<li>GCD(6, 4) = GCD(4, 6 % 4) = GCD(4, 2)</li>
<li>GCD(4, 2) = GCD(2, 4 % 2) = GCD(2, 0)</li>
</ul>
<p>Since B = 0,  GCD (2, 0)  will return 2.  </p>
<p><strong><em>Time complexity</em></strong><br />
The time complexity is <em>O(log(max(A, B)))</em>.  </p>
<p><strong>4. Extended Euclidean algorithm</strong></p>
<p>This algorithm is an extended form of Euclid’s algorithm.  GCD (A,B)  has a special property so that it can always be represented in the form of an equation i.e.  Ax+By = GCD (A, B) . </p>
<p>The coefficients (x and y) of this equation will be used to find the modular multiplicative inverse. The coefficients can be zero, positive or negative in value. </p>
<p>This algorithm takes two inputs as A and B and returns  GCD(A, B)  and coefficients of the above equation as output.</p>
<p><strong><em>Example</em></strong></p>
<p>If A=30 and B=20, then  30 * (1)+20 * (-1)=10  where 10 is the GCD of 20 and 30.</p>
<p><strong><em>Key idea</em></strong></p>
<p>A.x+B.y=GCD(A,B). ---(1)</p>
<p>You know that  GCD (A,B) = GCD (B,A \% B) . Therefore, you can write the equation as follows:
B. x_1 + (A % B). y_1 =GCD(A,B). ---(2)</p>
<p>You can write  A \% B = A - B * \lfloor{A / B}\rfloor  where  \lfloor \rfloor  means floor value .B and substitute it in equation 2. Your equation will be as follows:
B. x_1 + (A -  \lfloor{A / B}\rfloor .B). y_1 =GCD(A,B)<br /></p>
<p>When you solve it further, your equation is as follows:
B.( x_1  -  \lfloor{A / B}\rfloor . y_1 )+A. y_1 =GCD(A,B).  ---(3)</p>
<p>Comparing coefficients in equations 1 and 3, you get the following:</p>
<ul>
<li>x= y_1 </li>
<li>y= x_1  -  \lfloor{A / B}\rfloor . y_1 </li>
</ul>
<p>These equations are key in understanding the extended Euclidean algorithm.</p>
<p>In this algorithm, recursive calls are made to  GCD (B,A \% B) . The values that are returned from recursive calls are  x_1  and  y_1 , which are used to get x and y.<br /></p>
<p><strong><em>Implementation</em></strong></p>
<p></p><pre class="prettyprint"><code>#include &lt; iostream &gt;

int d, x, y;
void extendedEuclid(int A, int B) {
    if(B == 0) {
        d = A;
        x = 1;
        y = 0;
    }
    else {
        extendedEuclid(B, A%B);
        int temp = x;
        x = y;
        y = temp - (A/B)*y;
    }
}

int main( ) {
extendedEuclid(16, 10);
cout &lt;&lt; ”The GCD of 16 and 10 is ” &lt;&lt; d &lt;&lt; endl;
cout &lt;&lt; ”Coefficients x and y are ”&lt;&lt; x &lt;&lt;  “and  “ &lt;&lt; y &lt;&lt; endl;
return 0;   
}
</code></pre>
<strong>Output</strong><p></p>
<p></p><pre class="prettyprint"><code>The GCD of 16 and 10 is 2.
Coefficients x and y are 2 and -3.
</code></pre>
Initially, the extended Euclidean algorithm will run as Euclid's algorithm until you determine  GCD (A, B)  or until B = 0. It will then assign x = 1 and y = 0.  <p></p>
<p>In the current scenario, since B = 0 and  GCD (A, B)  is A, the equation  Ax + By = GCD (A, B)  will be changed to  A * 1 + 0 * 0 = A  .</p>
<p>The values of d, x, and y in the process of the extendedEuclid( ) function are as follows:<br /></p>
<ul>
<li> d = 2, x = 1, y = 0 </li>
<li> d = 2, x = 0 , y = 1 - (4 / 2) * 0 = 1 </li>
<li> d = 2, x = 1 , y = 0 - (6 / 4) * 1 = -1 </li>
<li> d = 2, x = -1 , y = 1- (10 / 6) * -1 = 2 </li>
<li> d = 2 , x = 2, y = -1- (16 / 10) * 2 = -3 </li>
</ul>
<p><strong><em>Time complexity</em></strong></p>
<p>The time complexity of the extended Euclidean algorithm is  O (log(max(A, B)))  .   </p>
<p><strong><em>When is this algorithm used?</em></strong></p>
<p>This algorithm is used when A and B are co-prime. In such cases, x becomes the multiplicative modulo inverse of A under modulo B, and y becomes the multiplicative modulo inverse of B under modulo A. This has been explained in detail in the <strong><em>Modular multiplicative inverse</em></strong> section.</p>
<p><strong>5. Modular multiplicative inverse</strong></p>
<p>What is a multiplicative inverse? If  A . B =1 , you are required to find B such that it satisfies the equation. The solution is simple. The value of B is  1 / A  or  A^{-1} . Here, B is the multiplicative inverse of A.</p>
<p>What is modular multiplicative inverse? If you have two numbers A and M, you are required to find B such it that satisfies the following equation:</p>
<p> (A . B) \% M =1 </p>
<p>Here B is the modular multiplicative inverse of A under modulo M.</p>
<p>Formally, if you have two integers A and M, B is said to be modular multiplicative inverse of A under modulo M if it satisfies the following equation:</p>
<p> A.B \equiv 1 (mod M) . where B is in the range [1,M-1]</p>
<p>This equation is a formal representation of the equation discussed earlier.</p>
<p><strong><em>Why is B in the range [1,M-1]?</em></strong></p>
<p> (A * B) \% M = (A \% M * B \% M) \% M </p>
<p>Since we have B%M, the inverse must be in the range [0,M-1]. However, since 0 is invalid, the inverse must be in the range [1,M-1].<br /></p>
<p><strong><em>Existence of modular multiplicative inverse</em></strong></p>
<p>An inverse exists only when A and M are coprime i.e.  GCD (A,M)=1 .<br /></p>
<p>For example, if A=5 and M=12, then  (A *5) \% M = (5 * 5) \% 12= 1. 
Here, 5 is the modular multiplicative inverse of 5 under modulo 12.<br />
Though  (5 * 17) \%12 = 1 , but since 17 &gt; 12, it isn't considered. </p>
<p>Therefore, the answer is 5.</p>
<p><strong><em>Approach 1 (naive approach)</em></strong></p>
<p></p><pre class="prettyprint"><code>int modInverse(int A,int M)
{
    A=A%M;
    for(int B=1;B&lt;M;B++)
        if((A*B)%M)==1)
            return B;
}
</code></pre>
<strong><em>Time Complexity</em></strong><p></p>
<p>The algorithm mentioned above runs in <em>O(M)</em>.</p>
<p><strong><em>Approach 2</em></strong></p>
<p>A and M are coprime i.e.  Ax+My = 1 . In the extended Euclidean algorithm, x is the modular multiplicative inverse of A under modulo M. Therefore, the answer is x. You can use the extended Euclidean algorithm to find the multiplicative inverse.<br /></p>
<p>For example, if A=5 and M=12, then  GCD (A,B)=1 . Therefore, the inverse exists.</p>
<p> 5 * (5) +12 * (-2) = 1  (which comes from the extended Euclidean algorithm). Therefore, 5 is the inverse of A=5 under modulo 12. </p>
<pre class="prettyprint"><code>int d,x,y;
int modInverse(int A, int M)
{
    extendedEuclid(A,M);
    return (x%M+M)%M;    //x may be negative
}
</code></pre>
<p><strong><em>Time complexity</em></strong></p>
<p><em>O(log(max(A,M)))</em></p>
<p><strong><em>Approach 3 (used only when M is prime)</em></strong></p>
<p>This approach uses <a href="https://en.wikipedia.org/wiki/Fermat%27s_little_theorem">Fermat's Little Theorem</a>. </p>
<p>The theorem specifies the following:
  A^{M-1} \equiv 1 (mod M) </p>
<p>By multiplying with  A^{-1}  both sides,the equation can be rewritten as follows:</p>
<p> A^{-1} \equiv A^{M - 2}(mod M) </p>
<p>The formula for  A^{-1}  is in the form of exponents. Therefore, modular exponentiation can be used to determine the result.</p>
<p>For example, if A=5 and M=11 then  A^{M - 2}(mod M) = 5^{9}(mod 11) = 9  is the inverse of 5 under modulo 11.  </p>
<p></p><pre class="prettyprint"><code>int modInverse(int A,int M)
{
    return modularExponentiation(A,M-2,M);
}
</code></pre>
<strong><em>Time complexity</em></strong>
<em>O(log M)</em><p></p>
<p><strong><em>When is modular inverse used?</em></strong></p>
<p>Modular inverse is used to solve  (A / B) \% M  as follows:
 (A / B) \% M = (A * B^{-1}) \% M 
After you find the inverse, you can solve this equation easily.</p>

			</p>
			<!-- Ajax loaded content here -->
		</div>
	</div>
	<!-- /view -->
	<script src="js/classie.js"></script>
	<script src="js/dummydata.js"></script>
	<script src="js/main.js"></script>
	<script>
	(function() {
		var menuEl = document.getElementById('ml-menu'),
			mlmenu = new MLMenu(menuEl, {
				// breadcrumbsCtrl : true, // show breadcrumbs
				// initialBreadcrumb : 'all', // initial breadcrumb text
				backCtrl : false, // show back button
				// itemsDelayInterval : 60, // delay between each menu item sliding animation
				onItemClick: loadDummyData // callback: item that doesn´t have a submenu gets clicked - onItemClick([event], [inner HTML of the clicked item])
			});

		// mobile menu toggle
		var openMenuCtrl = document.querySelector('.action--open'),
			closeMenuCtrl = document.querySelector('.action--close');

		openMenuCtrl.addEventListener('click', openMenu);
		closeMenuCtrl.addEventListener('click', closeMenu);

		function openMenu() {
			classie.add(menuEl, 'menu--open');
			closeMenuCtrl.focus();
		}

		function closeMenu() {
			classie.remove(menuEl, 'menu--open');
			openMenuCtrl.focus();
		}

		// simulate grid content loading
		var gridWrapper = document.querySelector('.content');

		function loadDummyData(ev, itemName) {
			ev.preventDefault();

			closeMenu();
			gridWrapper.innerHTML = '';
			classie.add(gridWrapper, 'content--loading');
			setTimeout(function() {
				classie.remove(gridWrapper, 'content--loading');
				gridWrapper.innerHTML = '<ul class="products">' + dummyData[itemName] + '<ul>';
			}, 700);
		}
	})();
	</script>
</body>

</html>
